"""This module defines the function for calculating the potentials and fields."""

from typing import Callable, Iterable, NamedTuple

import jax
import jax.numpy as jnp
import optimistix as optx
from jax import Array
from jax.typing import ArrayLike
from scipy.constants import c, epsilon_0, pi

from pycharge.charge import Charge


class Quantities(NamedTuple):
    scalar: Array
    vector: Array
    electric: Array
    magnetic: Array

    electric_term1: Array
    electric_term2: Array
    magnetic_term1: Array
    magnetic_term2: Array


def potentials_and_fields(
    charges: Iterable[Charge],
) -> Callable[[ArrayLike, ArrayLike, ArrayLike, ArrayLike], Quantities]:
    """
    Returns a function to compute electromagnetic fields and potentials generated by point charges at given
    spacetime points.

    Args:
        charges (Iterable[Charge]): An iterable containing Charge objects.

    Returns:
        callable: A function that takes (x, y, z, t) arrays and returns a Quantities object with fields and potentials.
    """

    charges = [charges] if isinstance(charges, Charge) else list(charges)

    if len(charges) == 0:
        raise ValueError("At least one charge must be provided.")

    for idx, charge in enumerate(charges):
        if not callable(charge.position):
            raise ValueError(f"Charge {idx} position must be a callable function of time.")

    position_fns = [lambda t, c=charge: jnp.asarray(c.position(t)) for charge in charges]  # Convert to array
    velocity_fns = [jax.jacobian(pos_fn) for pos_fn in position_fns]
    acceleration_fns = [jax.jacobian(vel_fn) for vel_fn in velocity_fns]
    source_time_fns = [source_time(charge) for charge in charges]
    qs = jnp.array([charge.q for charge in charges])

    def quantities_fn(x: ArrayLike, y: ArrayLike, z: ArrayLike, t: ArrayLike) -> Quantities:
        """
        Compute scalar and vector potentials, and electric and magnetic fields at spacetime points
        (x, y, z, t).
        """
        x, y, z, t = jnp.asarray(x), jnp.asarray(y), jnp.asarray(z), jnp.asarray(t)
        if not (x.shape == y.shape == z.shape == t.shape):
            raise ValueError("x, y, z, and t must have the same shape.")
        original_shape = x.shape

        r = jnp.stack([x, y, z], axis=-1)  # Stack into (..., 3)
        r_flat, t_flat = r.reshape(-1, 3), t.ravel()  # Flatten for vmap

        quantities_flat = jax.vmap(calculate_total_sources)(r_flat, t_flat)
        scalar_flat, other_quantities_flat = quantities_flat[0], quantities_flat[1:]

        return Quantities(
            scalar_flat.reshape(original_shape),  # 1D scalar quantity
            *(q.reshape(*original_shape, 3) for q in other_quantities_flat),  # 3D vectors quantities
        )

    def calculate_total_sources(r: Array, t: Array) -> tuple:
        """
        Computes the total fields at a single spacetime point (r, t) by summing the contributions from all
        charges.
        """

        # Solve for retarded times for each charge
        t_srcs = jnp.stack([fn(r, t) for fn in source_time_fns])
        # Evaluate source properties at the retarded times
        r_srcs = jnp.stack([pos_fn(tr) for pos_fn, tr in zip(position_fns, t_srcs)])
        v_srcs = jnp.stack([vel_fn(tr) for vel_fn, tr in zip(velocity_fns, t_srcs)])
        a_srcs = jnp.stack([acc_fn(tr) for acc_fn, tr in zip(acceleration_fns, t_srcs)])

        # Compute individual contributions
        calculate_individual_source_vmap = jax.vmap(calculate_individual_source, in_axes=(0, 0, 0, 0, None))
        individual_quantities = calculate_individual_source_vmap(r_srcs, v_srcs, a_srcs, qs, r)
        # Sum contributions from all charges
        summed_quantities = Quantities(*(jnp.sum(value, axis=0) for value in individual_quantities))

        return summed_quantities

    def calculate_individual_source(r_src: Array, v_src: Array, a_src: Array, q: Array, r: Array) -> tuple:
        """
        Computes the fields from a single charge at a single point (r, t).
        """
        R = jnp.linalg.norm(r - r_src)  # Distance from source to observation point
        n = (r - r_src) / R  # Unit vector from source to observation
        β = v_src / c  # Velocity normalized to speed of light
        β̇ = a_src / c  # Acceleration normalized to speed of light
        one_minus_β_dot_β = 1 - jnp.dot(β, β)
        one_minus_n_dot_β = 1 - jnp.dot(n, β)
        one_minus_n_dot_β_cubed = one_minus_n_dot_β**3
        n_minus_β = n - β
        coeff = q / (4 * pi * epsilon_0)  # Common coefficient

        # Potentials
        φ = coeff / (one_minus_n_dot_β * R)
        A = β * φ / c

        # Fields
        E1 = coeff * n_minus_β * one_minus_β_dot_β / (one_minus_n_dot_β_cubed * R**2)
        E2 = coeff * jnp.cross(n, jnp.cross(n_minus_β, β̇)) / (c * one_minus_n_dot_β_cubed * R)
        E = E1 + E2

        B1 = jnp.cross(n, E1) / c
        B2 = jnp.cross(n, E2) / c
        B = B1 + B2

        return Quantities(φ, A, E, B, E1, E2, B1, B2)

    return quantities_fn


def source_time(charge: Charge) -> Callable[[Array, Array], Array]:
    """
    Returns a function to compute the retarded time for a given field point and observation time.

    Args:
        charge: Charge object containing the trajectory.
        root_finder_config: Configuration for the root finder.

    Returns:
        Function that takes (r, t) and returns the retarded time tr.
    """

    def source_time_fn(r: Array, t: Array) -> Array:
        """
        Solve for tr such that |r - r_src(tr)| = c * (t - tr).
        """

        def fn(tr, _):
            return jnp.linalg.norm(r - jnp.asarray(charge.position(tr))) - c * (t - tr)

        solver = optx.Newton(charge.newton_rtol, charge.newton_atol)
        t_init = t - jnp.linalg.norm(r - jnp.asarray(charge.position(t))) / c  # Initial guess
        result = optx.root_find(fn, solver, t_init, max_steps=charge.root_find_max_steps)
        return result.value

    return source_time_fn
