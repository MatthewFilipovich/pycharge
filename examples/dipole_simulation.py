"""
Coupled Dipole Simulation
=========================

This example demonstrates how to simulate the coupled dynamics of two Lorentz
oscillators (dipoles). When dipoles are placed in close proximity, their
interaction modifies their radiative properties, leading to phenomena like
superradiance and subradiance.

In PyCharge, we can model this by creating multiple :class:`~pycharge.Source` objects and
passing them to the :func:`~pycharge.simulate` function. The simulation will self-consistently
solve for the motion of each charge as it is influenced by the fields
generated by all other charges in the system.

Here, we simulate two dipoles separated by 80 nm. We will then plot the
energy of the system over time to observe the collective decay.
"""

# %%
# Import necessary libraries
# --------------------------

import jax
import jax.numpy as jnp
import matplotlib.pyplot as plt
from scipy.constants import e, m_e

from pycharge import dipole_source, simulate

jax.config.update("jax_enable_x64", True)


# %%
# Define simulation parameters
# ----------------------------

separation = 80e-9  # Distance between dipoles along x-axis
initial_displacement = [0.0, 0.0, 1e-11]  # Initial charge separation
omega_0 = 100e12 * 2 * jnp.pi  # Natural angular frequency

# Simulation time
t_num = 20_000
dt = 1e-18
ts = jnp.linspace(0, (t_num - 1) * dt, t_num)


# %%
# Create the dipole sources
# --------------------------

dipole1 = dipole_source(
    d_0=initial_displacement,
    q=e,
    omega_0=omega_0,
    m=m_e,
    origin=[0.0, 0.0, 0.0],
)

dipole2 = dipole_source(
    d_0=initial_displacement,
    q=e,
    omega_0=omega_0,
    m=m_e,
    origin=[separation, 0.0, 0.0],
)

# We will also create an identical, isolated dipole to compare its decay rate.
isolated_dipole = dipole_source(
    d_0=initial_displacement,
    q=e,
    omega_0=omega_0,
    m=m_e,
    origin=[0.0, 0.0, 0.0],
)


# %%
# Set up and run the simulations
# -------------------------------

sim_coupled_fn = jax.jit(simulate([dipole1, dipole2], ts))
sim_isolated_fn = jax.jit(simulate([isolated_dipole], ts))

# Run the simulations
print("Running coupled dipole simulation...")
coupled_states = sim_coupled_fn()
print("Running isolated dipole simulation...")
isolated_state = sim_isolated_fn()
print("Simulations complete.")


# %%
# Analyze and plot the results
# ----------------------------


def calculate_energy(state, omega_0, m_eff):
    """Return total dipole energy (kinetic + potential) over time."""

    pos_history = state[:, :, 0, :]
    vel_history = state[:, :, 1, :]

    dipole_r = pos_history[:, 1, :] - pos_history[:, 0, :]
    dipole_v = vel_history[:, 1, :] - vel_history[:, 0, :]

    kinetic_energy = 0.5 * m_eff * jnp.linalg.norm(dipole_v, axis=-1) ** 2
    potential_energy = 0.5 * m_eff * omega_0**2 * jnp.linalg.norm(dipole_r, axis=-1) ** 2
    return kinetic_energy + potential_energy


# Calculate energy for the coupled system (we'll just look at the first dipole)
m_eff = m_e / 2
energy_coupled = calculate_energy(coupled_states[0], omega_0=omega_0, m_eff=m_eff)

# Calculate energy for the isolated system
energy_isolated = calculate_energy(isolated_state[0], omega_0=omega_0, m_eff=m_eff)

# Normalize the energy
energy_coupled /= energy_coupled.max()
energy_isolated /= energy_isolated.max()

# %%
# The plot below shows the normalized energy of one of the coupled dipoles
# compared to an identical isolated dipole. The coupled dipole exhibits a
# faster decay rate, a signature of superradiance.

fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(ts, energy_coupled, label="Coupled Dipole")
ax.plot(ts, energy_isolated, "--", label="Isolated Dipole")
ax.set_yscale("log")
ax.set_xlabel("Time (s)")
ax.set_ylabel("Normalized Energy")
ax.set_title("Energy Decay of Coupled vs. Isolated Dipoles")
ax.legend()
ax.grid(True, which="both", ls=":")
fig.tight_layout()
plt.show()
