Point Charges
=============

The scalar and vector potentials generated by a moving point charge in the Lorenz gauge are given by the `Liénard-Wiechert potentials <https://en.wikipedia.org/wiki/Liénard–Wiechert_potential>`_:

.. math::
   :label: eq3

   \varphi(\mathbf{r}, t) = \frac{1}{4\pi\varepsilon_0}\;\left[\frac{q}{(1-\boldsymbol{\beta}_s \cdot \mathbf{n}_s)\,R}\right]_{t_r},

.. math::
   :label: eq4

   \mathbf{A}(\mathbf{r}, t) = \frac{\mu_0 c}{4\pi}\;\left[\frac{q\,\boldsymbol{\beta}_s}{(1-\boldsymbol{\beta}_s \cdot \mathbf{n}_s)\,R}\right]_{t_r}
   = \frac{\boldsymbol{\beta}_s(t_r)}{c}\,\varphi(\mathbf{r}, t).

Here:

- :math:`\boldsymbol{\beta}_s = \mathbf{v}_s / c` is the source velocity in units of the speed of light.  
- :math:`\mathbf{n}_s = (\mathbf{r} - \mathbf{r}_s)/R` is the unit vector from the source position :math:`\mathbf{r}_s` to the field point :math:`\mathbf{r}`, with :math:`R = |\mathbf{r} - \mathbf{r}_s|`.  
- The subscript :math:`t_r` indicates that source quantities are evaluated at the retarded time :math:`t_r = t_r(\mathbf{r}, t)`, defined implicitly by

.. math::
   :label: eq5

   t_r = t - \frac{1}{c}\,|\mathbf{r} - \mathbf{r}_s(t_r)|.

The fields are obtained from the potentials by the usual relations

.. math::
   :label: eq6

   \mathbf{E}(\mathbf{r}, t) = -\nabla \varphi(\mathbf{r}, t) - \frac{\partial \mathbf{A}(\mathbf{r}, t)}{\partial t},

.. math::
   :label: eq7

   \mathbf{B}(\mathbf{r}, t) = \nabla \times \mathbf{A}(\mathbf{r}, t).

Carrying out the differentiations and evaluating all source quantities at the
retarded time yields the explicit expressions for the fields: 

.. math::
   :label: eq8

   \mathbf{E}(\mathbf{r}, t)
   = \frac{q}{4\pi\varepsilon_0} \left[
     \frac{\mathbf{n}_s - \boldsymbol{\beta}_s}{\gamma^{2}(1-\boldsymbol{\beta}_s \cdot \mathbf{n}_s)^{3}\,R^{2}} \;+\;
     \frac{\mathbf{n}_s \times \bigl\{(\mathbf{n}_s - \boldsymbol{\beta}_s) \times \dot{\boldsymbol{\beta}}_s\bigr\}}{c\,(1-\boldsymbol{\beta}_s \cdot \mathbf{n}_s)^{3}\,R}
   \right]_{t_r},

.. math::
   :label: eq9

   \mathbf{B}(\mathbf{r}, t)
   = \frac{\mathbf{n}_s(t_r)}{c} \times \mathbf{E}(\mathbf{r}, t).

In these expressions, the Lorentz factor is :math:`\gamma = 1/\sqrt{1-|\boldsymbol{\beta}_s|^2}`, and 
:math:`\dot{\boldsymbol{\beta}}_s` denotes the derivative of :math:`\boldsymbol{\beta}_s` with respect to time. 
The first term in Eq. :eq:`eq8` scales as :math:`1/R^{2}`
(Coulomb field), while the second term scales as :math:`1/R` (radiation field),
and thus dominates at large distances from an accelerating charge.

PyCharge Implementation
~~~~~~~~~~~~~~~~~~~~~~~

To compute the Liénard-Wiechert potentials and fields numerically, PyCharge
determines the retarded time :math:`t_r` for each charge and observation point by
solving the implicit relation in Eq. :eq:`eq5`. This root-finding problem is
implemented efficiently using the `Optimistix <https://docs.kidger.site/optimistix/>`_
library, a JAX-native optimization framework. By default, PyCharge uses a
Newton-style solver that is fully differentiable.

PyCharge supports calculating the fields for an arbitrary number of point charges by using the
superposition principle: the total scalar and vector potentials and the total
fields are obtained by summing the contributions from each point charge.

In PyCharge, each point charge is represented by a :class:`~pycharge.Charge`
object, which is initialized with a user-supplied trajectory function that
accepts time ``t`` and returns the position tuple ``(x, y, z)``. Velocity and
acceleration—required for Eq. :eq:`eq8`—are computed automatically using JAX’s
differentiation utilities (:meth:`jax.jacobian`).

Defining a :class:`~pycharge.Charge`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A charge's trajectory is specified using a Python function and passed to the
:class:`~pycharge.Charge` constructor:

.. code-block:: python

   import jax.numpy as jnp
   from scipy.constants import e
   from pycharge import Charge

   def helical_position(t):
       radius = 1e-10
       omega = 1e16
       velocity_z = 1e6

       x = radius * jnp.cos(omega * t)
       y = radius * jnp.sin(omega * t)
       z = velocity_z * t
       return x, y, z

   spiraling_charge = Charge(position=helical_position, q=-e)

Approximating continuous densities
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The charge and current densities of a point charge :math:`q` following a trajectory
:math:`\mathbf{r}_s(t)` with velocity :math:`\mathbf{v}_s(t)` are

.. math::
   :label: eq1

   \rho(\mathbf{r}, t) = q\,\delta\bigl[\mathbf{r} - \mathbf{r}_s(t)\bigr],

and

.. math::
   :label: eq2

   \mathbf{J}(\mathbf{r}, t) = q\,\mathbf{v}_s(t)\,\delta\bigl[\mathbf{r} - \mathbf{r}_s(t)\bigr].


A continuous charge density :math:`\rho(\mathbf{r})` may be approximated by
populating a region with many point charges whose individual charges are set
according to the desired density. Similarly, a current density
:math:`\mathbf{J}=\rho\mathbf{v}` can be approximated using point charges moving
along prescribed paths. The accuracy of such approximations improves with the
number of sample charges and with larger observation distances relative to the
sample region.

----

.. rubric:: References

- J.D. Jackson, *Classical Electrodynamics*, Ch. 14.1  

- D.J. Griffiths, *Introduction to Electrodynamics*, Ch. 10.3