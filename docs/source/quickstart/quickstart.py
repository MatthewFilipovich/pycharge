"""
Quickstart
==========

Introduction
============

The **PyCharge** package was developed for calculating and visualizing the electromagnetic fields and potentials generated by moving point charges that have predefined trajectories and dipoles that act as Lorentz oscillators. PyCharge can calculate the total fields and potentials, at specified grid points in space and time, generated by the point charges in the simulation. To calculate these fields and potentials, PyCharge exploits the principle of superposition in classical electrodynamics by calculating the individual contributions from each point charge and then summing the results.

The equations describing the scalar and vector potentials generated by a single moving point charge in a vacuum are given by the `Liénard–Wiechert potentials <https://en.wikipedia.org/wiki/Li%C3%A9nard%E2%80%93Wiechert_potential>`_. The complete and relativistically correct equations for the time-varying electric and magnetic fields can be derived from these potentials. The dipoles are governed by a differential equation of motion which is solved numerically at each time step. The theory and computational implementation of these equations in PyCharge are described in detail in the `Background Information <../background_information/point_charges.md>`_ section.

PyCharge currently supports two types of sources: point charges that have predefined trajectories (specified as parametric equations of motion in the :math:`x`, :math:`y`, and :math:`z` directions as functions of time), and Lorentz oscillators (i.e., oscillating electric dipoles). The Lorentz oscillators (LOs) consist of two equal and opposite point charges that oscillate around the origin position (center of mass) along the axis of polarization, with a dipole moment that is dynamically calculated at each time step by solving the governing harmonic oscillator differential equation. The LOs are driven by the electric field component along the direction of polarization generated by the other sources in the system (which includes their own scattered field).

Calculating the potentials and fields requires the velocity and acceleration, which are automatically obtained using JAX's automatic differentiation capabilities. The user only needs to provide the parametric equations of motion for the point charges.

As well, the LOs are naturally damped since they radiate energy as they oscillate, which dissipates kinetic energy (classically caused by *radiation reaction*) and decreases the dipole moment. This damping allows PyCharge to calculate the self-consistent radiative decay rates from LOs in arbitrary motion and also in the presence of interactions with other LOs, including collective effects such as superradiance and subradiance.

Motivation
==========

The majority of electrodynamics problems can be divided into two distinct classes: one in which the goal is to solve for the electromagnetic fields generated by specified sources of charge and current (e.g., antennas, radiation from multipole sources), and the other in which the motion of the charges and currents are to be determined based on the known fields in the system (e.g., motion of charges in electric and magnetic fields, energy-loss phenomena).

However, there exists another class of electrodynamics problems where the solution requires that the fields and sources are treated self-consistently. That is, a correct treatment of the problem must include the reaction of the radiation on the motion of the sources. The self-consistent treatment of sources and fields is an old and difficult problem that stems from one of the most fundamental aspects of physics: the nature of an elementary particle. This problem of self-consistency is not only limited to classical electrodynamics, as these difficulties also arise in quantum-mechanical discussions and modelings of these systems. Motivated by the need for an electrodynamics simulator that self-consistently treats the reaction of the radiation on the real-time motion of the point charge sources, we developed the open-source Python package **PyCharge**.

.. [#1] J. Jackson. *Classic Electrodynamics*. Chapter 17.1
.. [#2] L. Novotny, *Principles of Nano Optics*. Chapter 8

Before starting, make sure TorchOptics is installed (:ref:`installation`).
"""

# %%
# Import PyCharge and other necessary libraries
# ----------------------------------------------
#
# We first import the necessary PyCharge components:

import jax.numpy as jnp
import matplotlib.pyplot as plt
from scipy.constants import e

from pycharge import Charge, potentials_and_fields

# %% Define the position functions of a single charge
# Define the position functions of two stationary charges forming a dipole


def position1(t):
    x = -5e-10
    y = 0.0
    z = 0.0
    return x, y, z


def position2(t):
    x = 5e-10
    y = 0.0
    z = 0.0
    return x, y, z


# %%
# Create Charge objects and quantities function
charge1 = Charge(position1, e)
charge2 = Charge(position2, -e)
quantities_fn = potentials_and_fields([charge1, charge2])
# %%
# Define the observation grid in the x-y plane at z=0 and t=0
x = jnp.linspace(-1e-9, 1e-9, int(1e3))
y = jnp.linspace(-1e-9, 1e-9, int(1e3))
z = jnp.array([0])
t = jnp.array([0])

X, Y, Z, T = jnp.meshgrid(x, y, z, t, indexing="ij")

# %%
# Calculate the scalar potential at grid points
quantities = quantities_fn(X, Y, Z, T)  # Calculate all quantities (potential and fields)
scalar_potential = quantities.scalar

# %%
# Plot the potential along the observation grid

plt.figure()
plt.imshow(scalar_potential.squeeze().T, extent=(-1e-9, 1e-9, -1e-9, 1e-9), origin="lower", vmax=10, vmin=-10)
plt.colorbar(label="Scalar Potential (V)")
plt.xlabel("X Position (m)")
plt.ylabel("Y Position (m)")
plt.title("Scalar Potential of a stationary dipole")
plt.show()


# %%
# Oscillating Dipole


def position3(t):
    x = 1e-10 * jnp.sin(1e18 * t)
    y = 0.0
    z = 0.0
    return x, y, z


charge3 = Charge(position3, e)
quantities_fn = potentials_and_fields([charge3])
# %% Calculate the scalar potential at grid points
scalar_potential = quantities_fn(X, Y, Z, T).scalar
# %% Plot the potential along the observation grid
plt.imshow(
    scalar_potential.squeeze().T,
    extent=(-1e-9, 1e-9, -1e-9, 1e-9),
    origin="lower",
    vmax=10,
    vmin=0,
)
plt.colorbar(label="Scalar Potential (V)")
plt.xlabel("X Position (m)")
plt.ylabel("Y Position (m)")
plt.title("Scalar Potential of an Accelerating Charge")
plt.show()
