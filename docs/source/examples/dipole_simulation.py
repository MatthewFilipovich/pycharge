"""
Dipole Simulation
=================

In the last section, we calculated the fields and potentials in 3D space generated by an oscillating point charge at a specified time. This required using the ``OscillatingCharge`` class, which has a predefined trajectory. However, PyCharge can also simulate dipoles that act as Lorentz oscillators, where the trajectories of the charges in the dipole are not predefined. These are simulated in PyCharge using the ``Dipole`` class.

The two opposite (positive and negative) charges in the ``Dipole`` object do not have predefined trajectories, since the dipole's moment is dependent on the external electric field that acts as a driving force. The dipole moment is defined by the driven oscillator differential equation, which is solved dynamically in PyCharge at each time step. For more information about ``Dipole`` objects and how they are simulated in PyCharge, see the `Lorentz Oscillators <../background_information/lorentz_oscillators.md>`_ section.

Here, we provide a script (found at `examples/s_dipoles.py <https://github.com/MatthewFilipovich/pycharge/blob/master/examples/s_dipoles.py>`_) for simulating two transverse dipoles (s-dipoles) that act as Lorentz oscillators. We run the simulation over 40,000 time steps and then analyze the dipole moment as a function of time to determine the new decay rate (:math:`\gamma`) and frequency shift (:math:`\delta_{12}`). We then compare these results to the theoretical Green's function values.

First, we import the necessary Python packages and define the simulation variables. The two dipoles are separated by 80 nm along the :math:`x`-axis and are both polarized in the :math:`y` direction with an initial charge separation of 1 nm. Each point charge is instantiated with the default values for the charge (``e``) and mass (``m_e``). Note that the effective mass of the dipole is ``m_e/2``, as discussed in the `Lorentz Oscillators <../background_information/lorentz_oscillators.md>`_ section. The simulation is run over 40,000 time steps and uses a time step of ``1e-18``:

.. code-block:: python

    import numpy as np
    import pycharge as pc

    # Simulation variables
    init_r = 1e-9  # Initial charge separation along y-axis
    d_12 = 80e-9  # Distance between dipoles along x-axis
    omega_0 = 100e12*2*np.pi  # Natural angular frequency of the dipoles
    timesteps = 40000  # Number of time steps in the simulation
    dt = 1e-18  # Time step

    origin_list = ((0, 0, 0), (d_12, 0, 0))  # Dipole origin vectors
    init_r_list = ((0, init_r, 0), (0, init_r, 0))  # Initial charge displacements
    sources = (pc.Dipole(omega_0, origin_list[0], init_r_list[0]),
               pc.Dipole(omega_0, origin_list[1], init_r_list[1]))
    simulation = pc.Simulation(sources)

Next, we run the simulation. The dipole moment, as well as the electric driving fields, are saved to the ``Dipole`` object at each time step. When the simulation is completed, the ``Simulation`` object (which includes the ``Dipole`` objects) is saved to the file ``s_dipoles.dat``. We then compute the theoretical decay rate and frequency shift of the dipoles from the Green's function using the ``s_dipole_theory`` method. Finally, we calculate these properties from the kinetic energy of the dipole using the ``calculate_dipole_properties`` method, which also plots the actual kinetic energy and the estimated function fit:

.. code-block:: python

    # Simulation data of dipoles is saved to file 's_dipoles.dat'
    simulation.run(timesteps, dt, 's_dipoles.dat')

    # Calculate theoretical \delta and \gamma_12
    theory_delta_12, theory_gamma_12 = pc.s_dipole_theory(init_r, d_12, omega_0)
    # Calculate \delta and \gamma from simulation starting from 5000 time steps
    delta_12, gamma = pc.calculate_dipole_properties(
        sources[0], first_index=10000, plot=True
    )
    print('Delta_12 (theory):', theory_delta_12)
    print('Delta_12 (simulation):', delta_12)
    print('Gamma_12 (theory):', theory_gamma_12)
    print('Gamma (simulation):', gamma)
    print()

The output plot and values are shown below. Note that since the dipoles started in-phase, the decay rate values are related by :math:`\gamma = 1 + \gamma_{12}`.

.. figure:: ../../figs/s_dipoles_kinetic_energy.jpeg
   :align: center
   :width: 500px

::

    Delta_12 (theory): 156.92644882498607
    Delta_12 (simulation): 156.9188149970173
    Gamma_12 (theory): 0.9943859767792077
    Gamma (simulation): 1.9970287120394974



Simulate Moving Dipoles
=======================

In addition to stationary dipoles, PyCharge can self-consistently simulate moving dipoles with a time-dependent origin (center of mass) position. Other direct electromagnetic (EM) simulation approaches (e.g., the FDTD method) cannot accurately model moving dipoles, which can have practical importance for nanoscale interactions since real atoms are rarely stationary. Thus, PyCharge can be used to explore new physical phenomena that arise from this additional dipole motion (e.g., phonons in dipole chains).

Simulations with moving dipoles are performed in PyCharge by creating a function that accepts the time :math:`t` as a parameter and returns the position of the dipole's origin position at :math:`t` as a three-element array (:math:`x`, :math:`y`, :math:`z`). This function is then passed as a parameter when instantiating the ``Dipole`` object. An example of instantiating a ``Dipole`` object with a time-dependent origin is given below:

.. code-block:: python

    from numpy import pi, cos
    import pycharge as pc

    def fun_origin(t):
        x = 1e-10 * cos(1e12 * 2 * pi * t)
        return ((x, 0, 0))

    omega_0 = 100e12 * 2 * pi
    init_d = (0, 1e-9, 0)
    source = pc.Dipole(omega_0, fun_origin, init_d)

Simulate Coupled Dipoles
========================

.. note::

   See the background section on `Coupled Lorentz oscillators <../../background_information/coupled_LOs>`_ or the PyCharge paper for more information about the underlying physics of coupled dipoles.

Two coupled dipoles modeled as Lorentz oscillators (LOs) in a system can be simulated in PyCharge, and their modified radiative properties can be calculated. An example program for simulating two s-dipoles (transverse), which are polarized along the :math:`y` axis and separated by 80 nm along the :math:`x` axis, is shown below:

.. code-block:: python

    import pycharge as pc
    from numpy import pi
    timesteps = 40000
    dt = 1e-18
    omega_0 = 100e12 * 2 * pi
    origins = ((0, 0, 0), (80e-9, 0, 0))
    init_r = (0, 1e-9, 0)
    sources = (pc.Dipole(omega_0, origins[0], init_r),
               pc.Dipole(omega_0, origins[1], init_r))
    simulation = pc.Simulation(sources)
    simulation.run(timesteps, dt, 's_dipoles.dat')
    d_12, g_plus = pc.calculate_dipole_properties(
        sources[0], first_index=10000)
    d_12_th, g_12_th = pc.s_dipole_theory(
        r=1e-9, d_12=80e-9, omega_0=omega_0)

The two dipoles have a natural angular frequency :math:`\omega_0` of :math:`200\pi\times10^{12}` rad/s and are simulated over 40,000 time steps (with a time step :math:`dt` of :math:`10^{-18}` s). The two charges in the dipole both have a mass of :math:`m_e` (the effective mass of the dipole is :math:`m_e/2`) and a charge magnitude of :math:`e`. Once the simulation is complete, the ``Simulation`` and related source objects are saved into the file ``s_dipoles.dat``, which can be accessed for analyses.

The dipoles begin oscillating in phase with an initial charge displacement :math:`\mathbf{r}_{\mathrm{dip}}` of 1 nm, resulting in superradiance and a modified spontaneous emission rate :math:`\gamma^+`. The rate :math:`\gamma^+` and frequency shift :math:`\delta_{12}` are then calculated in PyCharge by curve fitting the kinetic energy of the dipole (using the kinetic energy values after the 10,000th time step). Theoretical values for :math:`\gamma_{12}` and :math:`\delta_{12}` are also calculated by PyCharge.

The radiative properties of two coupled dipoles as a function of separation can be calculated by repeatedly running the previous simulation while sweeping across a range of dipole separation values. Using this technique, the modified rate :math:`\gamma^+` and frequency shift :math:`\delta_{12}` for in-phase (superradiant) s- and p-dipoles, scaled by the free-space emission rate :math:`\gamma_0`, are plotted below. The theoretical results from QED theory are also shown, and the Python script can be found at `examples/paper_figures/figure7 <https://github.com/MatthewFilipovich/pycharge/blob/master/examples/paper_figures/figure7.py>`_:

.. figure:: ../../figs/figure7.png
   :align: center
   :width: 400px

We can also plot the normalized populations of the excited states of two coupled dipoles, :math:`\rho_{aa}(t)` and :math:`\rho_{bb}(t)`, using the normalized total energy of the dipoles at each time step. This yields particularly interesting results for coupled dipoles with small separations when one dipole is initially excited (:math:`\rho_{aa}(0)=1`) and the other is not (:math:`\rho_{bb}(0)=0`). In this scenario, the populations are a linear combination of the superradiant and subradiant states, which leads to the observed energy transfer between dipoles known as FÃ¶rster coupling. This phenomenon can be simulated in PyCharge by initializing the excited dipole with a much larger dipole moment (and total energy) than the other. The simulation results and analytical solution are shown below, and the script is given at `examples/paper_figures/figure8 <https://github.com/MatthewFilipovich/pycharge/blob/master/examples/paper_figures/figure8.py>`_:

.. figure:: ../../figs/figure8.png
   :align: center
   :width: 400px

Additionally, the dipole moment of one of the dipoles in the frequency domain is shown below, which clearly shows the frequency peaks of the subradiant and superradiant states. The dipole moment of an isolated LO in the frequency domain is also shown for comparison, and the Python script can be found at `examples/paper_figures/figure9 <https://github.com/MatthewFilipovich/pycharge/blob/master/examples/paper_figures/figure9.py>`_:

.. figure:: ../../figs/figure9.png
   :align: center
   :width: 400px


"""
