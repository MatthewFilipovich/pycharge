Quickstart 
==========

Welcome to PyCharge! This guide gives you a practical tour of the
electromagnetics workflows provided by the library.

PyCharge Workflows
------------------

PyCharge focuses on two complementary use cases:

1.  **Point Charge Electromagnetics**: Compute relativistically-correct
    electromagnetic potentials and fields from point charges with predefined
    trajectories.
2.  **Self-Consistent N-Body Electrodynamics**: Simulate the dynamics of
    electromagnetic sources—such as dipoles—that interact through their
    self-generated fields.

This guide will walk you through both. For detailed physical theory, please see
the :doc:`/user-guide/index`.


Installation
------------

Before starting, make sure PyCharge is installed:

.. code-block:: bash

    pip install pycharge

.. note::

     For numerical stability, most simulations should enable 64-bit floating
     point support in JAX by calling ``jax.config.update("jax_enable_x64", True)``
     once near the top of your script or notebook.

Part 1: Point Charge Electrodynamics
------------------------------------

Use this workflow when you already know the trajectory of a charge and need the
fields it produces. The :func:`pycharge.potentials_and_fields` helper consumes a
collection of ``Charge`` objects and returns a vectorized, JIT-ready evaluator
that accepts space-time grids.

Let's step through an end-to-end example.

1. Import the required libraries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. plot::
    :context: reset

    import jax
    import jax.numpy as jnp
    import matplotlib.pyplot as plt
    from scipy.constants import c, e, m_e

    from pycharge import Charge, dipole_source, potentials_and_fields, simulate

    jax.config.update("jax_enable_x64", True)

2. Define a charge trajectory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Provide a callable that accepts time ``t`` and returns ``(x, y, z)``. PyCharge
will differentiate this trajectory automatically to obtain velocity and
acceleration, so you only need the position.

Below we define a charge that moves along a circle in the x-y plane.

.. plot::
   :context:

   circular_radius = 1e-10
   velocity = 0.9 * c
   omega = velocity / circular_radius


   def circular_position(t):
       x = circular_radius * jnp.cos(omega * t)
       y = circular_radius * jnp.sin(omega * t)
       z = 0.0
       return x, y, z


   moving_charge = Charge(circular_position, e)

3. Build the potentials and fields function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With our ``Charge`` defined, we next construct a callable that computes the
potentials and fields generated by that configuration. The helper
:func:`pycharge.potentials_and_fields` takes a list of charges and returns a
function that maps observation points and time to the requested quantities.

For efficient, repeated evaluations, we JIT-compile this callable with
:func:`jax.jit`:

.. plot::
    :context:

    quantities_fn = potentials_and_fields([moving_charge])

    jit_quantities_fn = jax.jit(quantities_fn)

4. Create an observation grid and evaluate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next we define a 2D observation plane along the x-y axes at ``t = 0`` and ``z = 0``.
We then pass this mesh into the JIT-compiled callable to obtain
the fields everywhere on the plane:

.. plot::
    :context:

    grid_size = 1000
    xy_max = 5e-9
    x_grid = jnp.linspace(-xy_max, xy_max, grid_size)
    y_grid = jnp.linspace(-xy_max, xy_max, grid_size)
    z_grid = jnp.array([0.0])
    t_grid = jnp.array([0.0])

    X, Y, Z, T = jnp.meshgrid(x_grid, y_grid, z_grid, t_grid, indexing="ij")

    quantities = jit_quantities_fn(X, Y, Z, T)

5. Visualize selected outputs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The result is a :class:`typing.NamedTuple` containing JAX arrays for the
scalar potential, vector potential, electric field, and magnetic field. 
We can visualize any of these quantities; below we plot the scalar potential and 
the magnitude of the electric field on the observation plane:

.. plot::
   :context: close-figs

   scalar_potential = quantities.scalar
   electric_field = quantities.electric
   electric_field_magnitude = jnp.linalg.norm(electric_field, axis=-1)

   fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

   im1 = ax1.imshow(
       jnp.log10(scalar_potential.squeeze().T),
       extent=(x_grid.min(), x_grid.max(), y_grid.min(), y_grid.max()),
       origin="lower",
       cmap="viridis",
       vmax=1,
       vmin=-1,
   )
   fig.colorbar(im1, ax=ax1, label="Scalar Potential (V)")
   ax1.set_xlabel("X Position (m)")
   ax1.set_ylabel("Y Position (m)")
   ax1.set_title("Scalar Potential of a Circularly Moving Charge")

   im2 = ax2.imshow(
       electric_field_magnitude.squeeze().T,
       extent=(x_grid.min(), x_grid.max(), y_grid.min(), y_grid.max()),
       origin="lower",
       cmap="inferno",
       vmax=1e10,
       vmin=0,
   )
   fig.colorbar(im2, ax=ax2, label="Electric Field Magnitude (V/m)")
   ax2.set_xlabel("X Position (m)")
   ax2.set_ylabel("Y Position (m)")
   ax2.set_title("Electric Field of a Circularly Moving Charge")

   plt.tight_layout()
   plt.show()

---

Part 2: Self-Consistent N-Body Electrodynamics
----------------------------------------------

PyCharge can also simulate the dynamics of **sources** whose motion is governed
by the electromagnetic fields they and other sources generate. This is handled
by :func:`pycharge.simulate`, which takes a sequence of ``Source`` objects and
solves their coupled ordinary differential equations (ODEs) over a shared time
grid.

In this example, we simulate a dipole modeled as a **Lorentz oscillator**—a
classical analog of a two-level quantum system.
1. Create a dipole source
~~~~~~~~~~~~~~~~~~~~~~~~~

The :func:`pycharge.sources.dipole_source` function creates a ``Source`` that
encapsulates the dipole's initial separation, physical parameters, and ODE.

.. plot::
   :context: reset

   import jax
   import jax.numpy as jnp
   import matplotlib.pyplot as plt
   from scipy.constants import e, m_e

   from pycharge import dipole_source, simulate

   jax.config.update("jax_enable_x64", True)

   dipole = dipole_source(
       d_0=[0.0, 0.0, 1e-9],
       q=e,
       omega_0=100e12 * 2 * jnp.pi,
       m=m_e,
       origin=[0.0, 0.0, 0.0],
   )

2. Configure time steps and run ``simulate``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Define the discrete time axis, build the simulator, and execute it. JIT
compilation is optional but highly recommended.

.. plot::
    :context:

    t_start = 0.0
    t_num = 40_000
    dt = 1e-18
    ts = jnp.linspace(t_start, (t_num - 1) * dt, t_num)

    sim_fn = jax.jit(simulate([dipole], ts))

    source_states = sim_fn()

3. Analyze the simulation results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``source_states`` is a tuple whose entries match the order of the input sources.
Each entry has shape ``(num_steps, num_charges, 2, 3)`` and stores position and
velocity for every charge. Here we plot the z-coordinates of the dipole's
charges and observe the expected radiation damping.

.. plot::
    :context:

    dipole_state = source_states[0]

    position_history = dipole_state[:, :, 0, :]

    charge1_pos = position_history[:, 0, :]
    charge2_pos = position_history[:, 1, :]

    plt.figure(figsize=(10, 6))
    plt.plot(ts, charge1_pos[:, 2], label="Charge 1 (negative)")
    plt.plot(ts, charge2_pos[:, 2], label="Charge 2 (positive)")
    plt.xlabel("Time (s)")
    plt.ylabel("Z Position (m)")
    plt.title("Damped Oscillation of Charges in a Simulated Lorentz Dipole")
    plt.legend()
    plt.grid(True)
    plt.show()

Next Steps
==========

This quickstart has demonstrated the two main workflows in PyCharge:

1.  Calculating fields from charges with predefined trajectories.
2.  Simulating the dynamics of sources interacting with their own fields.

To dive deeper, explore the :doc:`/user-guide/index` for more detailed
explanations of the physics and the :doc:`/examples/index` for more
advanced use cases!