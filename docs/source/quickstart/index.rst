Quickstart 
==========

Welcome to PyCharge! This guide gives you an overview of the electromagnetics tools provided by the library.

PyCharge Workflows
------------------

PyCharge focuses on two complementary use cases:

1.  **Point Charge Electromagnetics**: Compute relativistically-correct
    electromagnetic potentials and fields from point charges with predefined
    trajectories.
2.  **Self-Consistent N-Body Electrodynamics**: Simulate the dynamics of
    electromagnetic sources—such as dipoles—that interact through their
    self-generated fields.

This guide will walk you through both workflows.


Installation
------------

Before starting, make sure PyCharge is installed:

.. code-block:: bash

    pip install pycharge

.. note::

     For numerical stability, most simulations should enable 64-bit floating
     point support in JAX by calling ``jax.config.update("jax_enable_x64", True)``
     once near the top of your script or notebook.

Part 1: Point Charge Electromagnetics
-------------------------------------

We first demonstrate how to compute the electromagnetic potentials and fields generated by point charges with 
predefined trajectories. 

1. Import the required libraries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. plot::
    :context: reset

    import jax
    import jax.numpy as jnp
    import matplotlib.pyplot as plt
    from scipy.constants import c, e, m_e

    from pycharge import Charge, dipole_source, potentials_and_fields, simulate

    jax.config.update("jax_enable_x64", True)

2. Define a charge trajectory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Provide a function that accepts time ``t`` and returns ``(x, y, z)``. PyCharge
will differentiate this trajectory automatically to obtain velocity and
acceleration, so you only need the position.

Below we define a :class:`~pycharge.Charge` that moves along a circle in the x-y plane.

.. plot::
   :context:

   circular_radius = 1e-10
   velocity = 0.9 * c
   omega = velocity / circular_radius


   def circular_position(t):
       x = circular_radius * jnp.cos(omega * t)
       y = circular_radius * jnp.sin(omega * t)
       z = 0.0
       return x, y, z


   moving_charge = Charge(circular_position, e)

3. Build the potentials and fields function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With our :class:`~pycharge.Charge` defined, we next construct a function that computes the
potentials and fields generated by that configuration. The helper
:func:`~pycharge.potentials_and_fields` takes a list of charges and returns a
function that maps observation points and time to the requested quantities.

For efficient, repeated evaluations, we JIT-compile this function with
:func:`jax.jit`:

.. plot::
    :context:

    quantities_fn = potentials_and_fields([moving_charge])

    jit_quantities_fn = jax.jit(quantities_fn)

4. Create an observation grid and evaluate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next we define a 2D observation plane along the x-y axes at ``t = 0`` and ``z = 0``.
We then pass this mesh into the JIT-compiled function to obtain
the potentials and fields at each point on the plane:

.. plot::
    :context:

    grid_size = 1000
    xy_max = 5e-9
    x_grid = jnp.linspace(-xy_max, xy_max, grid_size)
    y_grid = jnp.linspace(-xy_max, xy_max, grid_size)
    z_grid = jnp.array([0.0])
    t_grid = jnp.array([0.0])

    X, Y, Z, T = jnp.meshgrid(x_grid, y_grid, z_grid, t_grid, indexing="ij")

    quantities = jit_quantities_fn(X, Y, Z, T)

5. Visualize selected outputs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The output of the function, ``quantities``, is a :class:`~typing.NamedTuple` containing JAX arrays for the
scalar and vector potentials, and the electric and magnetic fields. 
We can visualize any of these quantities; below we plot the scalar potential and 
the magnitude of the electric field on the observation plane:

.. plot::
   :context: close-figs

   scalar_potential = quantities.scalar
   electric_field = quantities.electric
   electric_field_magnitude = jnp.linalg.norm(electric_field, axis=-1)

   fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

   im1 = ax1.imshow(
       scalar_potential.squeeze().T,
       extent=(x_grid.min(), x_grid.max(), y_grid.min(), y_grid.max()),
       origin="lower",
       cmap="viridis",
       vmax=10,
       vmin=0
   )
   fig.colorbar(im1, ax=ax1, label="Scalar Potential (V)")
   ax1.set_xlabel("X Position (m)")
   ax1.set_ylabel("Y Position (m)")
   ax1.set_title("Scalar Potential of a Circularly Moving Charge")

   im2 = ax2.imshow(
       electric_field_magnitude.squeeze().T,
       extent=(x_grid.min(), x_grid.max(), y_grid.min(), y_grid.max()),
       origin="lower",
       cmap="inferno",
       vmax=1e10,
       vmin=0,
   )
   fig.colorbar(im2, ax=ax2, label="Electric Field Magnitude (V/m)")
   ax2.set_xlabel("X Position (m)")
   ax2.set_ylabel("Y Position (m)")
   ax2.set_title("Electric Field of a Circularly Moving Charge")

   plt.tight_layout()
   plt.show()


Part 2: Self-Consistent N-Body Electrodynamics
----------------------------------------------

PyCharge can also simulate the dynamics of electrodynamic sources whose motion is governed
by the electromagnetic fields generated by themselves and other sources. This is handled
by :func:`~pycharge.simulate`, which takes a sequence of :class:`~pycharge.Source` objects and
solves their coupled ordinary differential equations (ODEs) over a shared time
grid.

In this example, we simulate the evolution of a dipole source.

1. Import the required libraries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. plot::
   :context: reset

   import jax
   import jax.numpy as jnp
   import matplotlib.pyplot as plt
   from scipy.constants import e, m_e

   from pycharge import dipole_source, simulate

   jax.config.update("jax_enable_x64", True)

2. Create a dipole source
~~~~~~~~~~~~~~~~~~~~~~~~~

The :func:`~pycharge.dipole_source` function creates a :class:`~pycharge.Source` that
encapsulates the dipole's initial separation, physical parameters, and ODE.

.. plot::
   :context:

   dipole = dipole_source(
       d_0=[0.0, 0.0, 1e-9],
       q=e,
       omega_0=100e12 * 2 * jnp.pi,
       m=m_e,
       origin=[0.0, 0.0, 0.0],
   )

3. Configure time steps and run the simulation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We next construct the simulation function that executes the electrodynamics simulation over 40,000 steps 
with a time step of ``1e-18`` seconds. The helper :func:`~pycharge.simulate` accepts a list of 
:class:`~pycharge.Source` objects and an array of discrete evaluation times, and returns a function that runs 
the simulation. For best performance, JIT-compile the returned function with :func:`jax.jit`.

.. plot::
    :context:

    t_num = 40_000
    dt = 1e-18
    ts = jnp.arange(t_num) * dt

    simulate_fn = jax.jit(simulate([dipole], ts))

    source_states = simulate_fn()

4. Analyze the simulation results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``source_states`` is a tuple whose entries match the order of the input sources.
Each entry has shape ``(num_steps, num_charges, 2, 3)`` and stores position and
velocity for every charge. Here we plot the z-coordinates of the dipole's
charges.

.. plot::
    :context:

    dipole_state = source_states[0]

    charge0_z_pos = dipole_state[:, 0, 0, 2]
    charge1_z_pos = dipole_state[:, 1, 0, 2]

    plt.figure(figsize=(10, 6))
    plt.plot(ts, charge0_z_pos, label="Charge 0 (negative)")
    plt.plot(ts, charge1_z_pos, label="Charge 1 (positive)")
    plt.xlabel("Time (s)")
    plt.ylabel("Z Position (m)")
    plt.title("Damped Oscillation of Charges in a Simulated Lorentz Dipole")
    plt.legend()
    plt.grid(True)
    plt.show()

Next Steps
==========

This quickstart has demonstrated the two main workflows in PyCharge:

1.  Calculating potentials and fields from charges with predefined trajectories.
2.  Simulating the dynamics of sources interacting with their own fields.

To dive deeper, explore the :doc:`/user-guide/index` for more detailed
explanations of the physics and the :doc:`/examples/index` for more
notebooks illustrating common use cases!